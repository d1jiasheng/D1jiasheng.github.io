<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>重学java（2）封装，继承，多态</title>
    <url>/2020/02/15/%E9%87%8D%E5%AD%A6java%EF%BC%882%EF%BC%89%E5%B0%81%E8%A3%85%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>#说明</p>
<p>java面向对象的主要特点是三个。封装、继承、多态，本内容主要讲解比较重要的知识点。</p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>具体来说，在java中使用private实现变量或者方法的私有化。</p>
<h2 id="不使用封装"><a href="#不使用封装" class="headerlink" title="不使用封装"></a>不使用封装</h2><p>首先我们在不使用封装的情况下创建一个类并初始化一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> String name = <span class="string">"小明"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//创建对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span></pre></td></tr></table></figure>

<p>此时直接使用person.name就能访问到person的姓名，这也太方便了吧，但是需要知道的是，使用public修饰的变量，在java任意位置的其他类都能访问到，比如，我建立了一个新的类，专门用来该你的名字</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//老王来了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Laowang</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change_name</span><span class="params">(Person person)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        person.name = <span class="string">"小王"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"你儿子归我了"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//老王偷你儿子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Laowang laowang = <span class="keyword">new</span> Laowang();</span></pre></td></tr><tr><td class="code"><pre><span class="line">laowang.change_name(person);</span></pre></td></tr></table></figure>

<p>然后你会发现你儿子的名字被改了。这个时候你就该想了，怎么样能让儿子不被偷呢？</p>
<h2 id="使用封装"><a href="#使用封装" class="headerlink" title="使用封装"></a>使用封装</h2><p>private就来了，private就是让你把自己的变量或者方法藏起来，更绝的是，你自己都不能直接访问自己的变量，那咋办呢，这个时候set和get方法就来了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name = <span class="string">"小明"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.age = age;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>

<p>然后我们就能通过get和set来访问和修改了，而老王他就改不了你的名字了。但是这个时候你会发现，别人还是可以通过set和get来访问和修改的，比如我们将getName的方法修改一下，再新建一个对象访问</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(Person p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> p.name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person();</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(person1.getName(person));</span></pre></td></tr></table></figure>

<p>这样还是能通过person1访问person的name变量，那set也能改了，也就是说，老王又可以改名字了。那咋办呢，那我们就在get方法里面加个判断吧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(Person p)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == p)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> p.name;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"你看个锤子看"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>然后你就发现其他对象就看不了名字了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>封装简单来看就是用private对类的成员变量和函数进行封装，然后再用get和set提供接口，同时可以使用this关键字进行更深层的判断。</p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为</p>
<p>具体实现时，在创建子类的时候，使用extends继承父类</p>
<h2 id="为什么使用继承"><a href="#为什么使用继承" class="headerlink" title="为什么使用继承"></a>为什么使用继承</h2><p>这个问题解释起来其实挺简单的，举个简单的例子就是比如狗和猫都有嘴巴，眼睛，都会吃，走，但是我们如果在每个类里面都把这些变量和方法都写一遍，就会使代码产生产生冗余。比较好的方法就是创建一个动物类，包含啦嘴巴和眼睛，都会走，吃，而让猫，狗类继承动物类，再在各自内部实现各自独有的变量和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动物类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> String eye;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">protected</span> String mouse;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Animal()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Animal create"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"animal eat"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"animal run"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//猫类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Cat()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"cat create"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"cat run"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//添加猫抓老鼠的功能</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get_moues</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"cat cna get moues"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//狗类</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Dog()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"dog create"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"dog run"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">//添加狗看门的功能</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watch_door</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"dog can watch door"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面的例子中，猫和狗就不用再定义眼睛和嘴巴了，因为在继承的时候，相当于隐式的将这些变量在自己类中定义了。</p>
<h2 id="构造函数和方法的重写"><a href="#构造函数和方法的重写" class="headerlink" title="构造函数和方法的重写"></a>构造函数和方法的重写</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>子类是无法继承父类的构造函数的，也就是说在Dog类里面不能定义Animal（）这个构造函数，但是在创建子类的时候可以调用。</p>
<p>如果父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类添加带参的构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal(String eye, String mouse)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.eye = eye;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">this</span>.mouse = mouse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//子类需要使用super调用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Cat(String eye, String mouse) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">super</span>(eye, mouse);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<p>如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。</p>
<p>子类在使用构造函数创建对象的时候都会先调用父类的构造对象，然后再调用自己的构造函数。</p>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><p>一般将重写，都会跟重载对应起来将。</p>
<p>重写又叫覆盖，发生在继承关系下的子类中。子类可以用自己的方式实现父类的方法，重写不能改变参数列表，也不能缩小方法的访问权限，如果父类方法抛出异常，子类抛出的异常不能比父类的异常“大”，也不能抛出新的异常。</p>
<p>上面的例子中，Animal内部有eat()方法，而Cat内部可以通过重写来改变eat()的内部实现，如果子类重写了父类的方法，那么在调用的时候就不会和构造函数一样再去父类调用一遍了。</p>
<p>需要注意的是，如果父类定义了一个private的方法，那么在子类中重新编写这个方法，都算不上重写，因为private修饰的方法是不能被子类继承的，重新编写这个函数只能算是子类自己重新构造了一个新的函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类的private函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"animal eat"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//子类用overide修饰会报错的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>而重载和继承没有任何关系（当然，继承之间也存在重载，也就是说，继承可以重载，但是重载不一定继承），它发生在类本身。重载方法的特点是方法名相同而参数列表不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"animal eat"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"animal eat1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">double</span> c)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		System.out.println(<span class="string">"animal eat2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>只需要记住，被重载的方法<strong>必须</strong>改变参数列表(参数个数或类型或顺序不一样)</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>多态，简而言之就是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>在java中，多态主要包括重写式多态和重载柿多态，也就是在继承中已经讲过的两个类别。</p>
<ul>
<li>重载式多态，也叫编译时多态。也就是说这种多态在编译时已经确定好了。方法名相同而参数列表不同的一组方法就是重载。在调用这种重载的方法时，通过传入不同的参数最后得到不同的结果。</li>
<li>重写式多态，也叫运行时多态。这种多态通过动态绑定（dynamic binding）技术来实现，是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。也就是说，只有程序运行起来，你才知道调用的是哪个子类的方法。</li>
</ul>
<h2 id="多态的条件"><a href="#多态的条件" class="headerlink" title="多态的条件"></a>多态的条件</h2><p>主要考虑运行时的多态，主要包含以下条件</p>
<ul>
<li><strong>继承</strong>。在多态中必须存在有继承关系的子类和父类。</li>
<li><strong>重写</strong>。子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li><strong>向上转型</strong>。在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
<p>继承与重写已经基本介绍过了，下面主要讲向上转型</p>
<h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>子类引用的对象转换为父类类型称为向上转型。通俗地说就是将子类对象转为父类对象。此处父类对象可以是接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span></pre></td></tr></table></figure>

<p>这就是向上转型，将子类创建的对象转化为父类对象，此时a调用的方法是子类Cat中的方法。</p>
<p>需要注意的是</p>
<ul>
<li>向上转型时，子类单独定义的方法会丢失。比如在Cat类中定义父类没有的方法，当Animal引用指向Cat类实例时是访问不到除了继承外的其他方法。</li>
<li>子类引用不能指向父类对象。<code>Cat c = (Cat)new Animal()</code>这样是不行的。</li>
</ul>
<p>向上转型可以使代码变得简洁</p>
<h2 id="多态中的注意事项"><a href="#多态中的注意事项" class="headerlink" title="多态中的注意事项"></a>多态中的注意事项</h2><p>在向上转型中，往往会涉及到函数的调用，由于父类和子类都定义了相同的函数，不知道应该调用哪一个。看下面这句话：</p>
<p><strong>当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。</strong></p>
<p>什么意思呢，比如我们有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal a)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"A_a"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Cat c)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"A_c"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Animal a)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"C_a"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Cat c)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"C_c"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal a = <span class="keyword">new</span> Cat();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Animal a1 = <span class="keyword">new</span> Animal();</span></pre></td></tr><tr><td class="code"><pre><span class="line">a.test(a1);</span></pre></td></tr></table></figure>

<p>a决定了可以调用的方法，也就是可以使用protected void test(Animal a)和protected void test(Cat c)，而Cat决定了调用哪个类中的方法，也就是使用Cat类中的test方法。</p>
<p><strong>继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)</strong></p>
<p>当子类无法在自身找到可调用的方法的时候，会根据上述的继承链依次调用。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>重学java（1）</title>
    <url>/2020/02/10/%E9%87%8D%E5%AD%A6java%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="java创建对象"><a href="#java创建对象" class="headerlink" title="java创建对象"></a>java创建对象</h2><p>java虚拟机主要包括4个部分：</p>
<ul>
<li><p>1.堆：存放对象。</p>
</li>
<li><p>2.栈：存放对象的引用。</p>
</li>
<li><p>3.静态区：存放被static修饰的变量。</p>
</li>
<li><p>4.常量区：存放常量。</p>
</li>
</ul>
<p>对于一条创建对象的语句，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Car();</span></pre></td></tr></table></figure>

<p>首先在堆区新建了一个Car（）对象，其次在栈区创建一个p引用，指向堆区新建的Car（）。</p>
<p>通过类新建一个对象，在堆区都会新建一块区域。</p>
<p>但是如果使用下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Car car1 = car;</span></pre></td></tr></table></figure>

<p>在栈区会新建一个car1的引用，而car1指向堆区的car（），也就是car和car1此时指向同一个的地址。</p>
<a id="more"></a>

<h2 id="数据和字符串"><a href="#数据和字符串" class="headerlink" title="数据和字符串"></a>数据和字符串</h2><p>通过new出来的对象都会放在堆，而java中有8大基本的数据类型，为了防止每次使用这些类型的时候都要消耗大量内存，这些数据的值都存在常量区中，比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span></pre></td></tr></table></figure>

<p>上述代码执行时，首先查看常量区是否存在2，不存在，开辟一块空间存放，在栈中开辟内存存放i并指向2，当需要创建j时，发现2已经存在，因此直接让j指向2。</p>
<p>但是如果用new的话，就不同了，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">2</span>);</span></pre></td></tr></table></figure>

<p>执行代码时候首先在堆中开辟内存存放2，栈中a指向2，接着再在堆中开辟内存存放2，栈中b指向2。也就是说，使用new在堆中存放对象时，是不会检查对象是否重复的，堆只会新建。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String直接赋值的数据也是存放在常量区，因此其使用方式与基本数据类型是一样的，比如下面的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">String b = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">String c = <span class="string">"abc"</span>;</span></pre></td></tr></table></figure>

<p>a,b,c三个变量指向的是同一个地址，此时如果改变a的值，令 a= “bcd”, 会在常量区新开辟一个空间存放bcd，a指向bcd，而b，c的指向的地址不变，仍然是abc。</p>
<p>而使用new String（）创建的字符串对象存放在堆中，直接创建的字符串常量值存放在常量区，这两个地址是不同的，看下面的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">String b = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span></pre></td></tr></table></figure>

<p>此时堆中开辟了两个空间，分别存放“abc”，而b此时和a指向同一个地址。接着，我们令a=’abc’，此时a指向了常量区新开辟的地址， b指向堆区的1号abc，c指向堆区的2号abc。</p>
<h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><ul>
<li>值传递：实参传递给形参的是值 ，形参和实参在内存上是两个独立的变量，对形参做任何修改不会影响实参。</li>
<li>引用传递：实参传递给形参的是参数对于堆内存上的引用地址，实参和形参在内存上指向 了同一块区域，对形参的修改会影响实参</li>
</ul>
<p>我们先看例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    testMain tm = <span class="keyword">new</span> testMain();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tm.change(a,b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"a:"</span> + a + <span class="string">"\n"</span> + <span class="string">"b:"</span> + b);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>[] a1 = &#123;<span class="number">10</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span>[] b1 = &#123;<span class="number">20</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tm.change1(a1,b1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(<span class="string">"a1:"</span> + a1[<span class="number">0</span>] + <span class="string">"\n"</span> + <span class="string">"b1:"</span> + b1[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> temp = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    b = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> temp = b[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    b[<span class="number">0</span>] = a[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a[<span class="number">0</span>] = temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面代码的输出</p>
<p>a:10<br>b:20<br>a1:20<br>b1:10</p>
<p>看完例子我们会以为，java在传常量的时候是值传递，而在传递数组，或者对象的时候是引用传递。</p>
<p>但是网上说的是，java只有值传递。更确切的说，java在从实参传递到函数的时候，是复制了一份实参的副本传递给形参。</p>
<p>先来分析第一个例子，在常量区开辟了两个空间，分别存放10和20，a和b指向了10和20，而在调用了change函数的时候，复制了a,b，假设是a’，b’，两个也分别指向常量区的10和20，而之后在函数里面的操作，就都是对a‘，b’的操作，并不会改变a,b的指向地址。</p>
<p>再分析第二个例子，同样在堆区开辟了两个空间存放数组，且a和b分别指向这两个空间，在调用change1函数后，复制出a‘，b’分别指向两个空间，但是，在函数里面是对a’指向的地址的数据进行操作，而不是a‘这个数据进行操作，也就是我们改变了a’指向的地址的内部数据导致了a指向的地址的内部数据改变，而a本身是没有改变了。好像有点绕口，总结一下就是虽然我们看到第二种方法改变了数据，但是它没有改变实参本身。</p>
<h2 id="clone实现浅拷贝"><a href="#clone实现浅拷贝" class="headerlink" title="clone实现浅拷贝"></a>clone实现浅拷贝</h2><p>java可以使用clone实现对话的浅拷贝，为什么说是浅拷贝，就是对象中但如果对象中存在如String类型，或者是数组类型的变量，clone并不会重新开辟一个空间，而是指向拷贝对象的空间，这个其实很像python中的浅拷贝。</p>
<p>java的浅拷贝需要类继承Clonable，并重写clone函数，具体类的实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> (Car)<span class="keyword">super</span>.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>克隆的时候就可以这么写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Car car = <span class="keyword">new</span> Car();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Car car_clone = (Car)car.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (Exception e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println(e.getStackTrace());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>测试一下浅拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(car.getName()==car_clone.getName()?<span class="string">"String类型不是额外开辟"</span>:<span class="string">"String类型是额外开辟"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(car.getSpeedHistory()==car_clone.getSpeedHistory()?<span class="string">"数组不是额外开辟"</span>:<span class="string">"数组是额外开辟"</span>);</span></pre></td></tr></table></figure>

<p>我们会发现克隆出来的car_clone对于String和数组还是和car共享同一个空间，因此称为浅拷贝。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>北京游</title>
    <url>/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>借着出差的机会去了一趟计划去的北京，但是时间不是很富裕，所以在12月6号选择了白天逛故宫，把游玩路线和照片整理一下。这次先把故宫游玩草草的写一下，有时间再补其他地方。</p>
<h2 id="故宫总图"><a href="#故宫总图" class="headerlink" title="故宫总图"></a>故宫总图</h2><p>先放一张故宫官方推荐的一日游玩路线图</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/故宫总图.png" alt="故宫总图" style="zoom: 67%;">

<a id="more"></a>

<p>其实游玩下来故宫主要分为上下两部分，上部分是各种寝宫，住的地方和玩的地方，下面是行政的地方。然后看网上的攻略有人说在人少的时候先去三大殿（太和、中和、保和），但是由于三大殿现在只能在殿外参观了（听旁边的导游说有游客为了拍龙椅经常会打起来，所以进不去了……），所以我的下半部分的路线在两者基础上做了修改。</p>
<h2 id="1-进宫前"><a href="#1-进宫前" class="headerlink" title="1.进宫前"></a>1.进宫前</h2><p>我是看完升旗后直接从天安门进的午门，因为升旗是<strong><u>7点21</u></strong>，升旗结束后大概<strong><u>7点35</u></strong>开放天安门，进了天安门右手边有个早餐店，可以先吃点东西，当然自己也能带东西的（感觉这个早餐店的小笼包还挺好吃的）。吃完大概是<strong>8点</strong>，因为怕排队人太多，就没有参观天安门，直接往里走了（后面发现周五人很少，不是节假日可以稍微慢一点）。中间需要穿过 <strong>端门</strong>，</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/IMG_3556.pdf" alt="IMG_3556" style="zoom: 67%;">

<p>穿过这个门之后差不多走个300米，就到午门外排队的地方了，而且是平行于午门站着（调侃这是古代太监等着皇帝召见）</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/午门.jpeg" alt="午门" style="zoom: 67%;">

<p>规定的入场时间是8点30，但是工作人员大概8点25就开放大门检票啦。然后就兴奋的进去了。</p>
<h2 id="2-8点30–中午"><a href="#2-8点30–中午" class="headerlink" title="2.8点30–中午"></a>2.8点30–中午</h2><p>进午门之后就能看到汉白玉石桥以及正对着的太和门，第一个拍照景点基本就是这个汉白玉石桥</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG8.jpeg" alt="WechatIMG8" style="zoom: 25%;">

<p>上面官方图的指引是在这个点往左右两边的武英殿和文化殿走，但我觉得还是要穿过太和门，先见一眼金銮殿。然后因为我一个人，也没啥好摆拍的，直接穿过汉白玉到太和门。</p>
<p>穿过太和门之后，就能见到雄伟的宫殿全貌，这里当然是要开全景图拍照的</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG11.jpeg" alt="WechatIMG11" style="zoom:50%;">

<p>往前走就是太和殿，也就是皇帝上早朝的地方，放龙椅的地方，但是现在已经不能进殿了，只能在外面拍照，还是挺可惜的。</p>
<p>参观完太和殿之后，并没有往后走，我从太和殿的右边下去，去文化殿参观。下台阶的时候，脑海里全是电视剧里面宫女太监下台阶的场景……</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG14.jpeg" alt="WechatIMG14" style="zoom:50%;">

<p>上图是下完台阶之后对着太和门拍照，不过好像亮度没调好，有点像日落。</p>
<p>然后就是往文化殿走，路上有好多小鸟，而且刚开始人很少，还是非常幽静的，遗憾的是，文华殿不开放，大门紧闭，我接着从汉白玉桥那边穿过去到武英殿，然后又没开门，我确实是有点服气的，既然不开放，这故宫游览图标出来是几个意思，想分散客流量？？？</p>
<p>然后我就从武英殿的侧面的路，差不多是太和殿到文华殿对称的路，又回到了太和殿，这个中轴线上。</p>
<p>接着就是参观中和殿与保和殿，我感觉拍宫殿里面没啥意思，因为在外面拍里面都是暗的，所以我尝试在不同角度拍了宫殿的外景。</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG17.jpeg" alt="WechatIMG17"></p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG18.jpeg" alt="WechatIMG18" style="zoom:80%;">



<p>每个宫殿逛完后，下了保和殿的台阶，可以看到乾清门</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG19.jpeg" alt="WechatIMG19" style="zoom:67%;">



<p>穿过乾清门，就可以看到皇帝起居的地方，乾清宫</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG20.jpeg" alt="WechatIMG20"></p>
<p>在印象中这个好像是唯一一个可以非常清楚看到内部样式的，可以仔细看看。</p>
<p>然后是交泰殿（没怎么停留）和坤宁宫，坤宁宫是皇后居住的地方，以及皇帝和皇后大婚的婚房（听导游讲皇帝大婚一般是要在这里住3天3夜，所以坤宁宫里面的东边两间是婚房的样子。）</p>
<p>参观完坤宁宫，从右侧下去，就可以开始参观西六宫了。进门前可以到门口拍一下六宫分布图，防止迷路，当然开着地图也行。</p>
<p>刚进去就是储秀宫的门口（看宫斗剧应该都听过），我感觉这个宫应该是开放的最像电视剧里面妃子宫殿的景点了</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG23.jpeg" alt="WechatIMG23"></p>
<p>当然，房子里面是进不去的。</p>
<p>宫殿外面的走道也挺有感觉的，就能想到电视剧里面两个宫斗的妃子在走道遇到的场景。</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG24.jpeg" alt="WechatIMG23"></p>
<p>以及有好几个没有开放的宫殿，只能透过门缝拍拍里面的路</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG25.jpeg" alt="WechatIMG25" style="zoom:50%;">

<p>之后的几个宫殿就没有怎么拍照了，因为感觉宫殿都差不多。</p>
<p>出了西六宫之后，我按照故宫地图想去找养心殿，跟着百度地图第一次路过没找到，然后第二次才看到养心殿在修整。</p>
<p>西六宫出来之后往南一直走，你就能看到你的西边会有一个比较大的宫殿，叫慈宁宫，这里面基本住的都是太皇太后，皇贵妃这些前一代皇帝的妃子，里面有个寿康宫就是好多电视剧里面太后住的地方，这里面的感觉就是宫殿里面有宫殿，进去一个门又有一个门。宫殿没拍，还是觉得里面的其他景色比较好看。</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG27.jpeg" alt="WechatIMG27"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG26.jpeg" alt="WechatIMG26"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG28.jpeg" alt="WechatIMG28"></p>
<p>从慈宁宫出来之后，差不多到饭店了，出来可以先去门口不远处的文创店逛逛，如果自己带了吃的，周围也有很多座位可以坐着吃。但是我在网上看有人说故宫的冰窖可以去吃吃看，就在慈宁宫出来右转，然后我去点了一碗炸酱面，怎么说呢，我是觉得不值的，还不如吃我自己带的面包呢。</p>
<h2 id="中午—3点"><a href="#中午—3点" class="headerlink" title="中午—3点"></a>中午—3点</h2><p>吃完面之后，可以在这边随便再走走，有些小的地点可以去看看，旁边的小花园呀，军机处呀，或者去文创店买点纪念品。</p>
<p>稍微休息之后就可以从西六宫那条路去御花园了，但是我逛御花园的感觉就是很乱，因为人很多，好多半日的阿姨大叔旅游团，他们只逛中轴线上的宫殿，然后可能路上边讲解边看走的很慢，到了快中午刚好逛到御花园，人就特别多，搞得我也没啥心情逛这里了</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG29.jpeg" alt="WechatIMG29"></p>
<p>就稍微走了走，人是真的多。</p>
<p>在御花园稍微坐了一会儿，就出发去逛东六宫了。御花园进门的第一个宫殿是钟粹宫（看过宫斗剧的应该也有印象吧），这个宫殿与西六宫的储秀宫相对应，也算是开放比较多的区域了吧。</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG37.jpeg" alt="WechatIMG37"></p>
<p>进去也是逛逛拍拍小角落的景色</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG30.jpeg" alt="WechatIMG30"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG31.jpeg" alt="WechatIMG31"></p>
<p>东六宫也是有几个宫殿是没有开放的，所以走了很多没必要的路。关着的宫殿里面的树都长出来了，看着就很萧条，很像冷宫的感觉</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG36.jpeg" alt="WechatIMG36"></p>
<p>东六宫的重头戏，当然是东南角延禧宫了，毕竟延禧攻略嘛。网上已经说过了就是个烂尾楼，我也就做好准备了。</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG34.jpeg" alt="WechatIMG34"></p>
<p>在东六宫里面走走，过道跟西六宫差不多，也是很有感觉的，还遇到了好几个穿着古装在拍照的。</p>
<p>逛完东六宫之后的大概20分钟，我就有点没有头绪的乱走，看到文创店就进去逛逛，不过都是卖的差不多的东西。</p>
<p>然后应该是在和西边慈宁宫对称的位置，有钟表馆和珍宝馆，在网上买票的时候应该都会看到，我在网上买票的时候没选，现场可以买票，钟表馆我没去，珍宝馆买票之后其实是宁寿宫景区，里面几个宫殿的长廊摆放着各种文物，而且珍妃井也在这个区域内，这个10块钱还是花的挺值的。</p>
<p>买完票进去后，也相当于一个宫殿群，同样的，我没怎么拍宫殿，拍的都是小景色……</p>
<p>里面有很多文物展出，可以仔细的逛逛，我当时就只在一侧逛，另一侧没去。</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG39.jpeg" alt="WechatIMG39"></p>
<p>有个小tip就是有些地方其实是可以进去会有另一个小空地的，比如有个戏台，我看好多人都没有进去</p>
<img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG40.jpeg" alt="WechatIMG40" style="zoom:50%;">

<p>然后就是很多景色，小角落的，说不出来，看着很有感觉，照片也拍不出那种感觉</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG42.jpeg" alt="WechatIMG42"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG41.jpeg" alt="WechatIMG41"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG43.jpeg" alt="WechatIMG43"></p>
<p>这个区域里面最有名就是最后的珍妃井了，就是慈禧把珍妃推下去的地方（不过我看这井口这么小，她怎么下去的）。</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG44.jpeg" alt="WechatIMG44"></p>
<p>逛完这个区域，差不多整个故宫就走马观花式的逛完了，不过我逛的比较快，所以我又回到了太和殿这里，想拍一下下午的景色，不过人太多了，就拍不出理想的照片，就只瞎拍了几张。</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG46.jpeg" alt="WechatIMG46"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG47.jpeg" alt="WechatIMG47"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG48.jpeg" alt="WechatIMG48"></p>
<p>然后午门门口这边可以上东南城楼，（不想回到出口的，可以在逛完珍宝馆出来之后上东北城楼）可以在城楼上面看到一些进不去的内景</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG50.jpeg" alt="WechatIMG50"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG51.jpeg" alt="WechatIMG51"></p>
<p>城楼应该是能连起来的，本来想在城楼上再整个逛一圈的，但是jio实在太痛，在城楼东华门出口下了楼梯，直接出故宫了，今天的故宫游基本就告一段落了。</p>
<h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>出了东华门，往东走可以去王府井大街，路上有一些店可以吃放，我选了一家人比较多的烤鸭店叫东门烤鸭，点了半只烤鸭，怎么说呢，味道也就那样吧。</p>
<p>吃完差不多走个10分钟，就能到王府井大街了，但是不知道是什么缘故，街上人不多，商场倒是很多，反正跟上海的南京东路差不多，王府井百货大楼北区进去地下二楼有个和平药局可以去看看，展示北京老街的</p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG53.jpeg" alt="WechatIMG53"></p>
<p><img src="/2019/12/06/%E5%8C%97%E4%BA%AC%E6%B8%B8/WechatIMG54.jpeg" alt="WechatIMG54"></p>
<p>王府井给我的唯一感觉就是，商场多，稻香村也多，就全是稻香村，卖老北京蜜饯小吃的。</p>
<p>逛完王府井，时间充裕的话，可以二选一</p>
<ul>
<li>地铁坐一站去天安门东</li>
<li>地铁或者叫车去后海酒吧，建议是打车，因为地铁要转4趟，每趟就1、2站，换站走路要走半天。</li>
</ul>
<p>然后一天就愉快的结束了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>故宫中轴线上的宫殿，说实话，现在不能进宫殿里面了，没内儿味儿了儿。我的观点是可以去侧面拍或者逞着人少去西六宫或者东六宫拍拍照，拍一拍全景啥的，宫殿真没啥好拍的。</li>
<li>逛的时候有不知道的可以问问工作人员，故宫的工作人员是真的多，也可以问一些关于历史的问题，比如有些房子是用来干什么的。</li>
<li>故宫吃东西的话，建议是自己带面包和水，是可以带的，冰窖吃饭是不怎么推荐的，要是想感受一下氛围可以去一下，东区有个餐馆没进去过不评价。</li>
<li>故宫的文创店很多，但是很多都是重复的，要是想买文创，但是人多的话，可以在慈宁宫出来右转，到冰窖的路上，第一个小入口进去，这里人少，而且东西也还挺全的。</li>
<li>最后就是穿一双合适的鞋吧。</li>
</ul>
]]></content>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中的小技巧(1)</title>
    <url>/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/</url>
    <content><![CDATA[<img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/图0.jpg" alt="图0" style="zoom:50%;">

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本系列主要用于记录在深度学习开发中我所遇到的感觉比较有用的小技巧，还是瞎写一下，感谢 <u><strong>憨憨</strong></u> 同学对本网站流量的大力支持</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Tip1：cuda9-0和10-0的切换"><a href="#Tip1：cuda9-0和10-0的切换" class="headerlink" title="Tip1：cuda9.0和10.0的切换"></a>Tip1：cuda9.0和10.0的切换</h3><p>tensorflow2.0的发布，要求cuda的版本从9.0升级到10.0，那么我们在安装cuda10.0之后，想要跑tensorflow1.X的GPU版本就会遇到报错：<strong><em>ImportError: DLL load failed: 找不到指定的模块</em></strong> 。意思就是tensorflow1.X是不能使用cuda10.0了，请教了别人，说是conda环境下安装toolkit可以实现切换？但是我就是不想用conda怎么办，这里就有一个比较笨的方法。</p>
<a id="more"></a>

<p>首先我们可以在电脑中同时安装cuda9.0和10.0的版本。具体安装过程就不说了，然后在我们的C盘中就有两个cuda的版本了，如下图：</p>
<p><img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/%E5%9B%BE1.PNG" alt="图1"></p>
<p>之后我们进入环境变量配置这两个cuda的环境，需要配置的变量主要有3个部分：</p>
<ul>
<li>cuda位置</li>
</ul>
<p><img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/%E5%9B%BE2.PNG" alt="图2"></p>
<ul>
<li><p>cuda sample 位置（这个我也不知道是干什么的）</p>
<p><img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/%E5%9B%BE3.PNG" alt="图2"></p>
</li>
<li><p>path中cuda lib和libnvvp配置</p>
<p><img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/%E5%9B%BE4.PNG" alt="图2"></p>
</li>
</ul>
<p>细心的朋友们就会发现，我这边配置的时候，把两个版本的路径都配置了一遍，但是cuda9.0的路径，我把文件夹名称改成了9.1，这样的好处就是系统在找10.0环境的时候，就不会去找9.0的路径了。上图环境变量下系统cuda版本号如下：</p>
<p><img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/%E5%9B%BE5.PNG" alt="图5"></p>
<p>那如果我们要改成9.0怎么办，那就手动吧9.1改成9.0，把10.0改成10.1，<strong>这里要注意的是前两个环境配置里面的第一个配置的10.0是要改成9.0而不是10.1奥</strong>。改完之后我们再看cuda版本号：</p>
<p><img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/%E5%9B%BE6.PNG" alt="图5"></p>
<p>这样就切换好了，然后就可以用tensorflow1.x啦</p>
<p>（好像还是有点麻烦的-_-）。</p>
<h3 id="Tip2：pycharm中的TODO标注"><a href="#Tip2：pycharm中的TODO标注" class="headerlink" title="Tip2：pycharm中的TODO标注"></a>Tip2：pycharm中的TODO标注</h3><p>第一次看到这个东西，是在用pycharm看别人代码的时候，第一眼看上去，我靠这什么，这标注这么亮瞎眼的吗，这黄光，金闪闪，不行，我要学。其实就是如下图的代码标注：</p>
<p><img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/%E5%9B%BE7.PNG" alt="图7"></p>
<p>就是在代码后面添加 <strong>#TODO：</strong>然后编写你想写的东西，这个标注主要是提醒你<strong>这个代码需要被检查或者未完成</strong>，所会高光展示。</p>
<p>同时在pycharm的工具栏底部，可以点开TODO，在里面可以看到文件中所有的TODO标注，点击就可以跳转到相应的代码行，如下图：</p>
<p><img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/%E5%9B%BE8.PNG" alt="图8"></p>
<p>有时候用来找代码可能还是比较方便的。</p>
<p>（虽然我现在也没怎么用过……）</p>
<h3 id="Tip3：tensorflow的-tf-einsum函数"><a href="#Tip3：tensorflow的-tf-einsum函数" class="headerlink" title="Tip3：tensorflow的 tf.einsum函数"></a>Tip3：tensorflow的 tf.einsum函数</h3><p>第一次见到这个函数，是在看baidu的DAM模型源代码的时候，当时就有点震惊，这啥玩意儿？看不懂，怎么写个表达式就能得到想要的结果了。先来大致感受一下这个函数：</p>
<img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/图9.png" alt="图9" style="zoom:50%;">

<p>上述代码的输出：</p>
<img src="/2019/11/29/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7-1/图10.png" alt="图10" style="zoom:50%;">

<p>你有感受到这个函数的便利吗，它不仅可以代替tf.matmul，或者是tf.multiply，还能在不同维度的张量之间进行指定的运算，这样的话在编写tensor之间的运算时，用这个简单的函数能够轻松的实现一些复杂的运算。</p>
<p>我们再来看看tf手册中对这个函数的定义。</p>
<p><strong>函数的参数</strong>：</p>
<ul>
<li><strong>equation</strong>：就是我们希望实现运算的式子</li>
<li><strong>*inputs</strong>：等式左边输入的张量，个数要与等式中出现的个数相同</li>
<li><strong>name</strong>：运算名称，可以忽略</li>
</ul>
<p><strong>函数的返回</strong>：与等式右边形式相同的张量</p>
<p>这个函数还是很简单就能上手了，学会合理使用能让你编写代码时事半功倍。</p>
<p>（我现在好像也只是在复现代码的时候使用过这个函数，嘻嘻）</p>
<h3 id="Tip4：（1，1）和（1，）是不一样的"><a href="#Tip4：（1，1）和（1，）是不一样的" class="headerlink" title="Tip4：（1，1）和（1，）是不一样的"></a>Tip4：（1，1）和（1，）是不一样的</h3><p>主要是有一次将自己的方法加入到别人代码的时候，发现metric函数一直报错，后来debug的时候发现，原来代码的输出的shape是（1，），在我改了结构之后输出的shape是（1，1），metric中计算准确率的方法就不行了。之前一直觉得这两个shape代表的是一样的，因为这两个看着都是一个括号一个逗号嘛，一看就是二维的，唉。</p>
<p>把这两个形状的tensor变成list输出看看：</p>
<img src="/Users/dijiasheng/myblog/source/_posts/深度学习中的小技巧-1/图11.png" alt="图11" style="zoom:50%;">

<p>就可以看出，前面的是2维的，后面的是一维的。</p>
<p>（你一维的加逗号干嘛呀，唉，关键去掉这个逗号程序还会报错）</p>
<h2 id="结尾瞎扯"><a href="#结尾瞎扯" class="headerlink" title="结尾瞎扯"></a>结尾瞎扯</h2><p>（我感觉也不知道有啥好瞎扯的技巧了，可能这期写完这个系列基本就玩完儿了吧…… 我太难了呀）</p>
<p>不过还是会在学习中注意一些比较好玩或者重要的东西，然后在这个系列中记一下的。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-11-29_大论文构思</title>
    <url>/2019/11/29/2018-11-29-%E5%A4%A7%E8%AE%BA%E6%96%87%E6%9E%84%E6%80%9D/</url>
    <content><![CDATA[<h1 id="大论文构思"><a href="#大论文构思" class="headerlink" title="大论文构思"></a>大论文构思</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>根据现有工作和之后想做的工作，构思一下可能要做的大论文结构，目前大致思路有2个。</p>
<h2 id="思路1-对话摘要"><a href="#思路1-对话摘要" class="headerlink" title="思路1-对话摘要"></a>思路1-对话摘要</h2><p>###思路描述</p>
<p>根据已有小论文进行拓展形成一篇大论文，在小论文中主要解决的问题主要有两点：</p>
<ul>
<li>如何解决对话摘要中的用户交互问题</li>
<li>如何解决对话过程中的主题转换检测问题</li>
</ul>
<a id="more"></a>

<h3 id="用户交互问题（dialogue-act-weight）"><a href="#用户交互问题（dialogue-act-weight）" class="headerlink" title="用户交互问题（dialogue-act-weight）"></a>用户交互问题（dialogue-act-weight）</h3><p>对话摘要不同于文本摘要，我们还需要关注用户对话的交互问题，小论文中提出了使用 <u><strong><em>dialogue act</em></strong></u> 作为额外的交互信息，dialogue act的表示如下图所示：</p>
<p><img src="/2019/11/29/2018-11-29-%E5%A4%A7%E8%AE%BA%E6%96%87%E6%9E%84%E6%80%9D/%E5%9B%BE1.png" alt="图1"></p>
<p>如上图所示，每一句话均有一个 dialogue act 与之对应，因此考虑作为额外信息输入，论文中设计拼接方式为下图所示：</p>
<p><img src="/2019/11/29/2018-11-29-%E5%A4%A7%E8%AE%BA%E6%96%87%E6%9E%84%E6%80%9D/%E5%9B%BE2.png" alt="图2"></p>
<p>由于同种标签对不同语句所提供的作用是不同的，我们没有直接将dialogue act拼接到dialogue后面，而是通过类似self-attention的方式计算标签权重后，再将每次输入的对话和与对话对应的dialogue act相拼接作为新的输入语句。</p>
<p>其中，<strong>dialogue act</strong>可以理解为每句话中包含的对话交互信息，它表明了每一句话对全文所起到的作用，比如suggest说明这句话是‘建议’，inform说明这句话包含了主要的‘信息’。</p>
<h3 id="主题转换检测问题（topic-change-info）"><a href="#主题转换检测问题（topic-change-info）" class="headerlink" title="主题转换检测问题（topic-change-info）"></a>主题转换检测问题（topic-change-info）</h3><p>一段文本往往只会产生一个主题，而一段对话其实会产生多个主题，本部分考虑添加主题转换信息让模型检测<strong>主题转变信息</strong>。</p>
<p>在对话中，往往主题转变之前，用户都会说一些转变对话的语句，在英文中 如 ‘uh, ok’，‘let‘s talk about another thing’之类的语句，这类语句如果只考虑全文含义理解，是并不重要的，但是对于我们的主题转变来说，它们恰好是需要我们关注的。</p>
<p>因此我们设计如下结构：</p>
<p><img src="/2019/11/29/2018-11-29-%E5%A4%A7%E8%AE%BA%E6%96%87%E6%9E%84%E6%80%9D/%E5%9B%BE3.png" alt="图3"></p>
<p>使用单向lstm得到对话的大致信息，每句话与该信息做<strong>相似计算</strong>得到一个权重，再用该权重与上一节中得到的dialogue act weight组合，得到的就是每句话提供的内容信息重要程度。之后使用减法或除法等方式使模型更关注转折部分，最终在模型解码时添入该部分信息。</p>
<h3 id="sentence-gate模型"><a href="#sentence-gate模型" class="headerlink" title="sentence-gate模型"></a>sentence-gate模型</h3><p>参考论文 <strong>“abstractive dialogue summarization with sentence-gated modeling optimized by dialogue act”</strong> 中所提到的sentence-gate机制，在解码时同时生成dialogue act 和 summarization，再通过summarization预测dialogue act，提高summarization的准确率。</p>
<h3 id="整体模型"><a href="#整体模型" class="headerlink" title="整体模型"></a>整体模型</h3><p>整体模型如下图所示：</p>
<p><img src="/2019/11/29/2018-11-29-%E5%A4%A7%E8%AE%BA%E6%96%87%E6%9E%84%E6%80%9D/%E5%9B%BE4.png" alt="图4"></p>
<h2 id="思路2-对话摘要与检索式多轮对话"><a href="#思路2-对话摘要与检索式多轮对话" class="headerlink" title="思路2-对话摘要与检索式多轮对话"></a>思路2-对话摘要与检索式多轮对话</h2><h3 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h3><p>检索式多轮对话的主要任务是给出对话和回复，给回复打分。当前的多轮对话中考虑了字和句子两方面粒度，希望能够使用对话摘要生成文本粒度并融入到多轮对话中。该部分还未开始研究</p>
<h3 id="对话摘要生成-文本粒度"><a href="#对话摘要生成-文本粒度" class="headerlink" title="对话摘要生成 文本粒度"></a>对话摘要生成 文本粒度</h3><p>这个部分探讨对话摘要的生成，以及探讨对话摘要对多轮对话进行文本粒度的生成，过往的论文中关注了<strong>字粒度</strong>和<strong>句子粒度</strong>，但是并没有关注文本粒度，不知道这个想法能否实现。</p>
<h3 id="多轮对话检索"><a href="#多轮对话检索" class="headerlink" title="多轮对话检索"></a>多轮对话检索</h3><p>探讨多轮对话检索以及根据对话摘要生成信息，并设计出能够将信息整合至对话检索的模型。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-11-28_我的第一篇hexo博客</title>
    <url>/2019/11/28/2019-11-28_%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="开始hexo"><a href="#开始hexo" class="headerlink" title="开始hexo"></a>开始hexo</h1><h4 id="首先感谢张蒸鱼同学对我搭建博客的大力支持，BlueFish的博客，老强化学习了。"><a href="#首先感谢张蒸鱼同学对我搭建博客的大力支持，BlueFish的博客，老强化学习了。" class="headerlink" title="首先感谢张蒸鱼同学对我搭建博客的大力支持，BlueFish的博客，老强化学习了。"></a>首先感谢张蒸鱼同学对我搭建博客的大力支持，<a href="https://bluefisher.github.io/" target="_blank" rel="noopener">BlueFish的博客</a>，老强化学习了。</h4><h4 id="其次，我也不知道这个博客能不能坚持更新点东西，反正是github免费的，嘻嘻。也没想好要写什么内容，要是有空就谢谢机器学习，深度学习，后面找工作再写写算法代码，当然这些都还不确定，嘿嘿。"><a href="#其次，我也不知道这个博客能不能坚持更新点东西，反正是github免费的，嘻嘻。也没想好要写什么内容，要是有空就谢谢机器学习，深度学习，后面找工作再写写算法代码，当然这些都还不确定，嘿嘿。" class="headerlink" title="其次，我也不知道这个博客能不能坚持更新点东西，反正是github免费的，嘻嘻。也没想好要写什么内容，要是有空就谢谢机器学习，深度学习，后面找工作再写写算法代码，当然这些都还不确定，嘿嘿。"></a>其次，我也不知道这个博客能不能坚持更新点东西，反正是github免费的，嘻嘻。也没想好要写什么内容，要是有空就谢谢机器学习，深度学习，后面找工作再写写算法代码，当然这些都还不确定，嘿嘿。</h4><h4 id="最后，再次感谢张蒸鱼同学对我搭建博客的支持，我们下期节目，再见"><a href="#最后，再次感谢张蒸鱼同学对我搭建博客的支持，我们下期节目，再见" class="headerlink" title="最后，再次感谢张蒸鱼同学对我搭建博客的支持，我们下期节目，再见"></a>最后，再次感谢张蒸鱼同学对我搭建博客的支持，我们下期节目，再见</h4>]]></content>
  </entry>
</search>
